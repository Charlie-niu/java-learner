### 三、命令

**Redis 是基于内存的数据存储兄，数据以 <key,value> 形式存储。 Value 支持多种数据类型，包括 String、hash、list、set、Sorted Set等。**

**Java常用的 redis 客户端编程驱动是 jedis**



### **字符串类型**

**1. 概述：**

字符串类型是 Redis 中最为基础的数据存储类型，它在Redis中是二进制安全的，这便意味着该类型可以接受任何格式的数据，如JPEG图像数据或Json对象描述信息等。在Redis中字符串类型的Value最多可以容纳的数据长度是512M。

常用的命令有： `get/set/mset/mget`

 **2. 相关命令列表：**

| **命令原型**                        | **时间复杂度** | **命令描述**                                                 | **返回值**                                            |
| ----------------------------------- | -------------- | ------------------------------------------------------------ | ----------------------------------------------------- |
| **APPEND**keyvalue                  | O(1)           | 如果该Key已经存在，APPEND命令将参数Value的数据追加到已存在Value的末尾。如果该Key不存在，APPEND命令将会创建一个新的Key/Value。 | 追加后Value的长度。                                   |
| **DECR**key                         | O(1)           | 将指定Key的Value原子性的递减1。如果该Key不存在，其初始值为0，在decr之后其值为-1。如果Value的值不能转换为整型值，如Hello，该操作将执行失败并返回相应的错误信息。注意：该操作的取值范围是64位有符号整型。 | 递减后的Value值。                                     |
| **INCR**key                         | O(1)           | 将指定Key的Value原子性的递增1。如果该Key不存在，其初始值为0，在incr之后其值为1。如果Value的值不能转换为整型值，如Hello，该操作将执行失败并返回相应的错误信息。注意：该操作的取值范围是64位有符号整型。 | 递增后的Value值。                                     |
| **DECRBY**key decrement             | O(1)           | 将指定Key的Value原子性的减少decrement。如果该Key不存在，其初始值为0，在decrby之后其值为-decrement。如果Value的值不能转换为整型值，如Hello，该操作将执行失败并返回相应的错误信息。注意：该操作的取值范围是64位有符号整型。 | 减少后的Value值。                                     |
| **INCRBY**key increment             | O(1)           | 将指定Key的Value原子性的增加increment。如果该Key不存在，其初始值为0，在incrby之后其值为increment。如果Value的值不能转换为整型值，如Hello，该操作将执行失败并返回相应的错误信息。注意：该操作的取值范围是64位有符号整型。 | 增加后的Value值。                                     |
| **GET**key                          | O(1)           | 获取指定Key的Value。如果与该Key关联的Value不是string类型，Redis将返回错误信息，因为GET命令只能用于获取string Value。 | 与该Key相关的Value，如果该Key不存在，返回nil。        |
| **SET**key value                    | O(1)           | 设定该Key持有指定的字符串Value，如果该Key已经存在，则覆盖其原有值。 | 总是返回"OK"。                                        |
| **GETSET**key value                 | O(1)           | 原子性的设置该Key为指定的Value，同时返回该Key的原有值。和GET命令一样，该命令也只能处理string Value，否则Redis将给出相关的错误信息。 | 返回该Key的原有值，如果该Key之前并不存在，则返回nil。 |
| **STRLEN**key                       | O(1)           | 返回指定Key的字符值长度，如果Value不是string类型，Redis将执行失败并给出相关的错误信息。 | 返回指定Key的Value字符长度，如果该Key不存在，返回0。  |
| **SETEX**key seconds value          | O(1)           | 原子性完成两个操作，一是设置该Key的值为指定字符串，同时设置该Key在Redis服务器中的存活时间(秒数)。该命令主要应用于Redis被当做Cache服务器使用时。 |                                                       |
| **SETNX**key value                  | O(1)           | 如果指定的Key不存在，则设定该Key持有指定字符串Value，此时其效果等价于SET命令。相反，如果该Key已经存在，该命令将不做任何操作并返回。 | 1表示设置成功，否则0。                                |
| **SETRANGE**key offset value        | O(1)           | 替换指定Key的部分字符串值。从offset开始，替换的长度为该命令第三个参数value的字符串长度，其中如果offset的值大于该Key的原有值Value的字符串长度，Redis将会在Value的后面补齐(offset -  strlen(value))数量的0x00，之后再追加新值。如果该键不存在，该命令会将其原值的长度假设为0，并在其后添补offset个0x00后再追加新值。鉴于字符串Value的最大长度为512M，因此offset的最大值为536870911。最后需要注意的是，如果该命令在执行时致使指定Key的原有值长度增加，这将会导致Redis重新分配足够的内存以容纳替换后的全部字符串，因此就会带来一定的性能折损。 | 修改后的字符串Value长度。                             |
| **GETRANGE**key start end           | O(1)           | 如果截取的字符串长度很短，我们可以该命令的时间复杂度视为O(1)，否则就是O(N)，这里N表示截取的子字符串长度。该命令在截取子字符串时，将以闭区间的方式同时包含start*(0**表示第一个字符**)*和end所在的字符，如果end值超过Value的字符长度，该命令将只是截取从start开始之后所有的字符数据。 | 子字符串                                              |
| **SETBIT**key offset value          | O(1)           | 设置在指定Offset上BIT的值，该值只能为1或0，在设定后该命令返回该Offset上原有的BIT值。如果指定Key不存在，该命令将创建一个新值，并在指定的Offset上设定参数中的BIT值。如果Offset大于Value的字符长度，Redis将拉长Value值并在指定Offset上设置参数中的BIT值，中间添加的BIT值为0。最后需要说明的是Offset值必须大于0。 | 在指定Offset上的BIT原有值。                           |
| **GETBIT**key offset                | O(1)           | 返回在指定Offset上BIT的值，0或1。如果Offset超过string value的长度，该命令将返回0，所以对于空字符串始终返回0。 | 在指定Offset上的BIT值。                               |
| **MGET**key [key ...]               | O(N)           | N表示获取Key的数量。返回所有指定Keys的Values，如果其中某个Key不存在，或者其值不为string类型，该Key的Value将返回nil。 | 返回一组指定Keys的Values的列表。                      |
| **MSET**key value [key value ...]   | O(N)           | N表示指定Key的数量。该命令原子性的完成参数中所有key/value的设置操作，其具体行为可以看成是多次迭代执行SET命令。 | 该命令不会失败，始终返回OK。                          |
| **MSETNX**key value [key value ...] | O(N)           | N表示指定Key的数量。该命令原子性的完成参数中所有key/value的设置操作，其具体行为可以看成是多次迭代执行SETNX命令。然而这里需要明确说明的是，*如果在这一批**Keys**中有任意一个**Key**已经存在了，那么该操作将全部回滚，即所有的修改都不会生效。* | 1表示所有Keys都设置成功，0则表示没有任何Key被修改。   |

 

###  **List 类型**

**1. 概述：**

在Redis中，List类型是按照插入顺序排序的字符串链表。和数据结构中的普通链表一样，我们可以在其头部(left)和尾部(right)添加新的元素。在插入时，如果该键并不存在，Redis将为该键创建一个新的链表。与此相反，如果链表中所有的元素均被移除，那么该键也将会被从数据库中删除。List中可以包含的最大元素数量是4294967295。
从元素插入和删除的效率视角来看，如果我们是在链表的两头插入或删除元素，这将会是非常高效的操作，即使链表中已经存储了百万条记录，该操作也可以在常量时间内完成。然而需要说明的是，如果元素插入或删除操作是作用于链表中间，那将会是非常低效的。相信对于有良好数据结构基础的开发者而言，这一点并不难理解。

常用命令：`Lpush/lpop，rpush/rpop`

 **2. 相关命令列表：**

| **命令原型**                              | **时间复杂度** | **命令描述**                                                 | **返回值**                                                   |
| ----------------------------------------- | -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **LPUSH** key value [value ...]           | O(1)           | 在指定Key所关联的List Value的头部插入参数中给出的所有Values。如果该Key不存在，该命令将在插入之前创建一个与该Key关联的空链表，之后再将数据从链表的头部插入。如果该键的Value不是链表类型，该命令将返回相关的错误信息。 | 插入后链表中元素的数量。                                     |
| **LPUSHX** key value                      | O(1)           | 仅有当参数中指定的Key存在时，该命令才会在其所关联的List Value的头部插入参数中给出的Value，否则将不会有任何操作发生。 | 插入后链表中元素的数量。                                     |
| **LRANGE** key start stop                 | O(S+N)         | 时间复杂度中的S为start参数表示的偏移量，N表示元素的数量。该命令的参数start和end都是0-based。即0表示链表头部(leftmost)的第一个元素。其中start的值也可以为负值，-1将表示链表中的最后一个元素，即尾部元素，-2表示倒数第二个并以此类推。该命令在获取元素时，start和end位置上的元素也会被取出。如果start的值大于链表中元素的数量，空链表将会被返回。如果end的值大于元素的数量，该命令则获取从start(包括start)开始，链表中剩余的所有元素。 | 返回指定范围内元素的列表。                                   |
| **LPOP**key                               | O(1)           | 返回并弹出指定Key关联的链表中的第一个元素，即头部元素，。如果该Key不存，返回nil。 | 链表头部的元素。                                             |
| **LLEN**key                               | O(1)           | 返回指定Key关联的链表中元素的数量，如果该Key不存在，则返回0。如果与该Key关联的Value的类型不是链表，则返回相关的错误信息。 | 链表中元素的数量。                                           |
| **LREM**key count value                   | O(N)           | 时间复杂度中N表示链表中元素的数量。在指定Key关联的链表中，删除前count个值等于value的元素。如果count大于0，从头向尾遍历并删除，如果count小于0，则从尾向头遍历并删除。如果count等于0，则删除链表中所有等于value的元素。如果指定的Key不存在，则直接返回0。 | 返回被删除的元素数量。                                       |
| **LSET**key index value                   | O(N)           | 时间复杂度中N表示链表中元素的数量。但是设定头部或尾部的元素时，其时间复杂度为O(1)。设定链表中指定位置的值为新值，其中0表示第一个元素，即头部元素，-1表示尾部元素。如果索引值Index超出了链表中元素的数量范围，该命令将返回相关的错误信息。 |                                                              |
| **LINDEX** key index                      | O(N)           | 时间复杂度中N表示在找到该元素时需要遍历的元素数量。对于头部或尾部元素，其时间复杂度为O(1)。该命令将返回链表中指定位置(index)的元素，index是0-based，表示头部元素，如果index为-1，表示尾部元素。如果与该Key关联的不是链表，该命令将返回相关的错误信息。 | 返回请求的元素，如果index超出范围，则返回nil。               |
| **LTRIM**key start stop                   | O(N)           | N表示被删除的元素数量。该命令将仅保留指定范围内的元素，从而保证链接中的元素数量相对恒定。start和stop参数都是0-based，0表示头部元素。和其他命令一样，start和stop也可以为负值，-1表示尾部元素。如果start大于链表的尾部，或start大于stop，该命令不错报错，而是返回一个空的链表，与此同时该Key也将被删除。如果stop大于元素的数量，则保留从start开始剩余的所有元素。 |                                                              |
| **LINSERT** key BEFORE\|AFTER pivot value | O(N)           | 时间复杂度中N表示在找到该元素pivot之前需要遍历的元素数量。这样意味着如果pivot位于链表的头部或尾部时，该命令的时间复杂度为O(1)。该命令的功能是在pivot元素的前面或后面插入参数中的元素value。如果Key不存在，该命令将不执行任何操作。如果与Key关联的Value类型不是链表，相关的错误信息将被返回。 | 成功插入后链表中元素的数量，如果没有找到pivot，返回-1，如果key不存在，返回0。 |
| **RPUSH** key value [value ...]           | O(1)           | 在指定Key所关联的List Value的尾部插入参数中给出的所有Values。如果该Key不存在，该命令将在插入之前创建一个与该Key关联的空链表，之后再将数据从链表的尾部插入。如果该键的Value不是链表类型，该命令将返回相关的错误信息。 | 插入后链表中元素的数量。                                     |
| **RPUSHX** key value                      | O(1)           | 仅有当参数中指定的Key存在时，该命令才会在其所关联的List Value的尾部插入参数中给出的Value，否则将不会有任何操作发生。 | 插入后链表中元素的数量。                                     |
| **RPOP**key                               | O(1)           | 返回并弹出指定Key关联的链表中的最后一个元素，即尾部元素，。如果该Key不存，返回nil。 | 链表尾部的元素。                                             |
| **RPOPLPUSH**source destination           | O(1)           | 原子性的从与source键关联的链表尾部弹出一个元素，同时再将弹出的元素插入到与destination键关联的链表的头部。如果source键不存在，该命令将返回nil，同时不再做任何其它的操作了。如果source和destination是同一个键，则相当于原子性的将其关联链表中的尾部元素移到该链表的头部。 | 返回弹出和插入的元素。                                       |

 

 

### **Set类型**

**1. 概述：**

在Redis中，我们可以将Set类型看作为没有排序的字符集合，和List类型一样，我们也可以在该类型的数据值上执行添加、删除或判断某一元素是否存在等操作。需要说明的是，这些操作的时间复杂度为O(1)，即常量时间内完成次操作。Set可包含的最大元素数量是4294967295。
和List类型不同的是，Set集合中不允许出现重复的元素，这一点和C++标准库中的set容器是完全相同的。换句话说，如果多次添加相同元素，Set中将仅保留该元素的一份拷贝。和List类型相比，Set类型在功能上还存在着一个非常重要的特性，即在服务器端完成多个Sets之间的聚合计算操作，如unions、intersections和differences。由于这些操作均在服务端完成，因此效率极高，而且也节省了大量的网络IO开销。

常用命令：`Sadd/srem/spop/scard/sort`

 **2. 相关命令列表：**

| **命令原型**                             | **时间复杂度** | **命令描述**                                                 | **返回值**                                        |
| ---------------------------------------- | -------------- | ------------------------------------------------------------ | ------------------------------------------------- |
| **SADD**key member [member ...]          | O(N)           | 时间复杂度中的N表示操作的成员数量。如果在插入的过程用，参数中有的成员在Set中已经存在，该成员将被忽略，而其它成员仍将会被正常插入。如果执行该命令之前，该Key并不存在，该命令将会创建一个新的Set，此后再将参数中的成员陆续插入。如果该Key的Value不是Set类型，该命令将返回相关的错误信息。 | 本次操作实际插入的成员数量。                      |
| **SCARD**key                             | O(1)           | 获取Set中成员的数量。                                        | 返回Set中成员的数量，如果该Key并不存在，返回0。   |
| **SISMEMBER**key member                  | O(1)           | 判断参数中指定成员是否已经存在于与Key相关联的Set集合中。     | 1表示已经存在，0表示不存在，或该Key本身并不存在。 |
| **SMEMBERS** key                         | O(N)           | 时间复杂度中的N表示Set中已经存在的成员数量。获取与该Key关联的Set中所有的成员。 | 返回Set中所有的成员。                             |
| **SPOP**key                              | O(1)           | 随机的移除并返回Set中的某一成员。 由于Set中元素的布局不受外部控制，因此无法像List那样确定哪个元素位于Set的头部或者尾部。 | 返回移除的成员，如果该Key并不存在，则返回nil。    |
| **SREM**key member [member ...]          | O(N)           | 时间复杂度中的N表示被删除的成员数量。从与Key关联的Set中删除参数中指定的成员，不存在的参数成员将被忽略，如果该Key并不存在，将视为空Set处理。 | 从Set中实际移除的成员数量，如果没有则返回0。      |
| **SRANDMEMBER** key                      | O(1)           | 和SPOP一样，随机的返回Set中的一个成员，不同的是该命令并不会删除返回的成员。 | 返回随机位置的成员，如果Key不存在则返回nil。      |
| **SMOVE**source destination member       | O(1)           | 原子性的将参数中的成员从source键移入到destination键所关联的Set中。因此在某一时刻，该成员或者出现在source中，或者出现在destination中。如果该成员在source中并不存在，该命令将不会再执行任何操作并返回0，否则，该成员将从source移入到destination。如果此时该成员已经在destination中存在，那么该命令仅是将该成员从source中移出。如果和Key关联的Value不是Set，将返回相关的错误信息。 | 1表示正常移动，0表示source中并不包含参数成员。    |
| **SDIFF**key [key ...]                   | O(N)           | 时间复杂度中的N表示所有Sets中成员的总数量。返回参数中第一个Key所关联的Set和其后所有Keys所关联的Sets中成员的差异。如果Key不存在，则视为空Set。 | 差异结果成员的集合。                              |
| **SDIFFSTORE**destination key [key ...]  | O(N)           | 该命令和SDIFF命令在功能上完全相同，两者之间唯一的差别是SDIFF返回差异的结果成员，而该命令将差异成员存储在destination关联的Set中。如果destination键已经存在，该操作将覆盖它的成员。 | 返回差异成员的数量。                              |
| **SINTER**key [key ...]                  | O(N*M)         | 时间复杂度中的N表示最小Set中元素的数量，M则表示参数中Sets的数量。该命令将返回参数中所有Keys关联的Sets中成员的交集。因此如果参数中任何一个Key关联的Set为空，或某一Key不存在，那么该命令的结果将为空集。 | 交集结果成员的集合。                              |
| **SINTERSTORE**destination key [key ...] | O(N*M)         | 该命令和SINTER命令在功能上完全相同，两者之间唯一的差别是SINTER返回交集的结果成员，而该命令将交集成员存储在destination关联的Set中。如果destination键已经存在，该操作将覆盖它的成员。 | 返回交集成员的数量。                              |
| **SUNION** key [key ...]                 | O(N)           | 时间复杂度中的N表示所有Sets中成员的总数量。该命令将返回参数中所有Keys关联的Sets中成员的并集。 | 并集结果成员的集合。                              |
| **SUNIONSTORE**destination key [key ...] | O(N)           | 该命令和SUNION命令在功能上完全相同，两者之间唯一的差别是SUNION返回并集的结果成员，而该命令将并集成员存储在destination关联的Set中。如果destination键已经存在，该操作将覆盖它的成员。 | 返回并集成员的数量。                              |

 

 

### **hash类型**

**1. 概述：**

我们可以将Redis中的Hashes类型看成具有String Key和String Value的map容器。所以该类型非常适合于存储值对象的信息。如Username、Password和Age等。如果Hash中包含很少的字段，那么该类型的数据也将仅占用很少的磁盘空间。每一个Hash可以存储4294967295个键值对。
 常用命令：`Hget/hset/hgetall`

 **2. 相关命令列表：**

| **命令原型**                               | **时间复杂度** | **命令描述**                                                 | **返回值**                                                   |
| ------------------------------------------ | -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **HSET** key field value                   | O(1)           | 为指定的Key设定Field/Value对，如果Key不存在，该命令将创建新Key以参数中的Field/Value对，如果参数中的Field在该Key中已经存在，则用新值覆盖其原有值。 | 1表示新的Field被设置了新值，0表示Field已经存在，用新值覆盖原有值。 |
| **HGET** key field                         | O(1)           | 返回指定Key中指定Field的关联值。                             | 返回参数中Field的关联值，如果参数中的Key或Field不存，返回nil。 |
| **HEXISTS**key field                       | O(1)           | 判断指定Key中的指定Field是否存在。                           | 1表示存在，0表示参数中的Field或Key不存在。                   |
| **HLEN** key                               | O(1)           | 获取该Key所包含的Field的数量。                               | 返回Key包含的Field数量，如果Key不存在，返回0。               |
| **HDEL** key field [field ...]             | O(N)           | 时间复杂度中的N表示参数中待删除的字段数量。从指定Key的Hashes Value中删除参数中指定的多个字段，如果不存在的字段将被忽略。如果Key不存在，则将其视为空Hashes，并返回0. | 实际删除的Field数量。                                        |
| **HSETNX**key field value                  | O(1)           | 只有当参数中的Key或Field不存在的情况下，为指定的Key设定Field/Value对，否则该命令不会进行任何操作。 | 1表示新的Field被设置了新值，0表示Key或Field已经存在，该命令没有进行任何操作。 |
| **HINCRBY**key field increment             | O(1)           | 增加指定Key中指定Field关联的Value的值。如果Key或Field不存在，该命令将会创建一个新Key或新Field，并将其关联的Value初始化为0，之后再指定数字增加的操作。该命令支持的数字是64位有符号整型，即increment可以负数。 | 返回运算后的值。                                             |
| **HGETALL**key                             | O(N)           | 时间复杂度中的N表示Key包含的Field数量。获取该键包含的所有Field/Value。其返回格式为一个Field、一个Value，并以此类推。 | Field/Value的列表。                                          |
| **HKEYS**key                               | O(N)           | 时间复杂度中的N表示Key包含的Field数量。返回指定Key的所有Fields名。 | Field的列表。                                                |
| **HVALS**key                               | O(N)           | 时间复杂度中的N表示Key包含的Field数量。返回指定Key的所有Values名。 | Value的列表。                                                |
| **HMGET**key field [field ...]             | O(N)           | 时间复杂度中的N表示请求的Field数量。获取和参数中指定Fields关联的一组Values。如果请求的Field不存在，其值返回nil。如果Key不存在，该命令将其视为空Hash，因此返回一组nil。 | 返回和请求Fields关联的一组Values，其返回顺序等同于Fields的请求顺序。 |
| **HMSET**key field value [field value ...] | O(N)           | 时间复杂度中的N表示被设置的Field数量。逐对依次设置参数中给出的Field/Value对。如果其中某个Field已经存在，则用新值覆盖原有值。如果Key不存在，则创建新Key，同时设定参数中的Field/Value。 |                                                              |

  

### **Sorted-sets 类型**

**1. 概述：**

Sorted-Sets和Sets类型极为相似，它们都是字符串的集合，都不允许重复的成员出现在一个Set中。它们之间的主要差别是Sorted-Sets中的每一个成员都会有一个分数(score)与之关联，Redis正是通过分数来为集合中的成员进行从小到大的排序。然而需要额外指出的是，尽管Sorted-Sets中的成员必须是唯一的，但是分数(score)却是可以重复的。
在Sorted-Set中添加、删除或更新一个成员都是非常快速的操作，其时间复杂度为集合中成员数量的对数。由于Sorted-Sets中的成员在集合中的位置是有序的，因此，即便是访问位于集合中部的成员也仍然是非常高效的。事实上，Redis所具有的这一特征在很多其它类型的数据库中是很难实现的，换句话说，在该点上要想达到和Redis同样的高效，在其它数据库中进行建模是非常困难的。

 **2. 相关命令列表：**

| **命令原型**                                                 | **时间复杂度** | **命令描述**                                                 | **返回值**                                              |
| ------------------------------------------------------------ | -------------- | ------------------------------------------------------------ | ------------------------------------------------------- |
| **ZADD** key score member [score]  [member]                  | O(log(N))      | 时间复杂度中的N表示Sorted-Sets中成员的数量。添加参数中指定的所有成员及其分数到指定key的Sorted-Set中，在该命令中我们可以指定多组score/member作为参数。如果在添加时参数中的某一成员已经存在，该命令将更新此成员的分数为新值，同时再将该成员基于新值重新排序。如果键不存在，该命令将为该键创建一个新的Sorted-Sets Value，并将score/member对插入其中。如果该键已经存在，但是与其关联的Value不是Sorted-Sets类型，相关的错误信息将被返回。 | 本次操作实际插入的成员数量。                            |
| **ZCARD** key                                                | O(1)           | 获取与该Key相关联的Sorted-Sets中包含的成员数量。             | 返回Sorted-Sets中的成员数量，如果该Key不存在，返回0。   |
| **ZCOUNT**key min max                                        | O(log(N)+M)    | 时间复杂度中的N表示Sorted-Sets中成员的数量，M则表示min和max之间元素的数量。该命令用于获取分数(score)在min和max之间的成员数量。*针对**min**和**max**参数需要额外说明的是，****-inf\****和****+inf\****分别表示**Sorted-Sets**中分数的最高值和最低值。缺省情况下，**min**和**max**表示的范围是闭区间范围，即****min <= score <= max\****内的成员将被返回。然而我们可以通过在**min**和**max**的前面添加**"**(**"**字符来表示开区间，如**(min max**表示****min < score <= max\****，而**(min (max**表示****min < score < max\****。* | 分数指定范围内成员的数量。                              |
| **ZINCRBY**key increment member                              | O(log(N))      | 时间复杂度中的N表示Sorted-Sets中成员的数量。该命令将为指定Key中的指定成员增加指定的分数。如果成员不存在，该命令将添加该成员并假设其初始分数为0，此后再将其分数加上increment。如果Key不存，该命令将创建该Key及其关联的Sorted-Sets，并包含参数指定的成员，其分数为increment参数。如果与该Key关联的不是Sorted-Sets类型，相关的错误信息将被返回。 | 以字符串形式表示的新分数。                              |
| **ZRANGE**key start stop [WITHSCORES]                        | O(log(N)+M)    | 时间复杂度中的N表示Sorted-Set中成员的数量，M则表示返回的成员数量。该命令返回顺序在参数start和stop指定范围内的成员，这里start和stop参数都是0-based，即0表示第一个成员，-1表示最后一个成员。如果start大于该Sorted-Set中的最大索引值，或start > stop，此时一个空集合将被返回。如果stop大于最大索引值，该命令将返回从start到集合的最后一个成员。*如果命令中带有可选参数**WITHSCORES**选项，该命令在返回的结果中将包含每个成员的分数值，如**value1,score1,value2,score2...**。* | 返回索引在start和stop之间的成员列表。                   |
| **ZRANGEBYSCORE** key min max [WITHSCORES] [LIMIT  offset count] | O(log(N)+M)    | 时间复杂度中的N表示Sorted-Set中成员的数量，M则表示返回的成员数量。该命令将返回分数在min和max之间的所有成员，即满足表达式min <= score  <= max的成员，其中返回的成员是按照其分数从低到高的顺序返回，如果成员具有相同的分数，则按成员的字典顺序返回。可选参数LIMIT用于限制返回成员的数量范围。可选参数offset表示从符合条件的第offset个成员开始返回，同时返回count个成员。可选参数WITHSCORES的含义参照ZRANGE中该选项的说明。*最后需要说明的是参数中**min**和**max**的规则可参照命令**ZCOUNT**。* | 返回分数在指定范围内的成员列表。                        |
| **ZRANK** key member                                         | O(log(N))      | 时间复杂度中的N表示Sorted-Set中成员的数量。Sorted-Set中的成员都是按照分数从低到高的顺序存储，该命令将返回参数中指定成员的位置值，其中0表示第一个成员，它是Sorted-Set中分数最低的成员。 | 如果该成员存在，则返回它的位置索引值。否则返回nil。     |
| **ZREM** key member [member ...]                             | O(M log(N))    | 时间复杂度中N表示Sorted-Set中成员的数量，M则表示被删除的成员数量。该命令将移除参数中指定的成员，其中不存在的成员将被忽略。如果与该Key关联的Value不是Sorted-Set，相应的错误信息将被返回。 | 实际被删除的成员数量。                                  |
| **ZREVRANGE** key startstop[WITHSCORES]                      | O(log(N)+M)    | 时间复杂度中的N表示Sorted-Set中成员的数量，M则表示返回的成员数量。该命令的功能和ZRANGE基本相同，唯一的差别在于该命令是通过反向排序获取指定位置的成员，即从高到低的顺序。如果成员具有相同的分数，则按降序字典顺序排序。 | 返回指定的成员列表。                                    |
| **ZREVRANK**key member                                       | O(log(N))      | 时间复杂度中的N表示Sorted-Set中成员的数量。该命令的功能和ZRANK基本相同，唯一的差别在于该命令获取的索引是从高到低排序后的位置，同样0表示第一个元素，即分数最高的成员。 | 如果该成员存在，则返回它的位置索引值。否则返回nil。     |
| **ZSCORE**key member                                         | O(1)           | 获取指定Key的指定成员的分数。                                | 如果该成员存在，以字符串的形式返回其分数，否则返回nil。 |
| **ZREVRANGEBYSCORE**key max min [WITHSCORES] [LIMIT offset  count] | O(log(N)+M)    | 时间复杂度中的N表示Sorted-Set中成员的数量，M则表示返回的成员数量。该命令除了排序方式是基于从高到低的分数排序之外，其它功能和参数含义均与ZRANGEBYSCORE相同。 | 返回分数在指定范围内的成员列表。                        |
| **ZREMRANGEBYRANK**key start stop                            | O(log(N)+M)    | 时间复杂度中的N表示Sorted-Set中成员的数量，M则表示被删除的成员数量。删除索引位置位于start和stop之间的成员，start和stop都是0-based，即0表示分数最低的成员，-1表示最后一个成员，即分数最高的成员。 | 被删除的成员数量。                                      |
| **ZREMRANGEBYSCORE**key min max                              | O(log(N)+M)    | 时间复杂度中的N表示Sorted-Set中成员的数量，M则表示被删除的成员数量。删除分数在min和max之间的所有成员，即满足表达式min <= score  <= max的所有成员。对于min和max参数，可以采用开区间的方式表示，具体规则参照ZCOUNT。 | 被删除的成员数量。                                      |

 

###  **Key 相关的命令**

**1. 概述：**
上文，主要讲述的是与Redis数据类型相关的命令，如String、List、Set、Hashes和Sorted-Set。这些命令都具有一个共同点，即所有的操作都是针对与Key关联的Value的。而该篇博客将主要讲述与Key相关的Redis命令。学习这些命令对于学习Redis是非常重要的基础，也是能够充分挖掘Redis潜力的利器。
常用命令`del/move`

 **2. 相关命令列表：**

| **命令原型**                                                 | **时间复杂度** | **命令描述**                                                 | **返回值**                                                   |
| ------------------------------------------------------------ | -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **KEYS** pattern                                             | O(N)           | 时间复杂度中的N表示数据库中Key的数量。获取所有匹配pattern参数的Keys。需要说明的是，在我们的正常操作中应该尽量避免对该命令的调用，因为对于大型数据库而言，该命令是非常耗时的，对Redis服务器的性能打击也是比较大的。*pattern**支持**glob-style**的通配符格式，如*****表示任意一个或多个字符，**?**表示任意字符，**[abc]**表示方括号中任意一个字母。* | 匹配模式的键列表。                                           |
| **DEL** key [key ...]                                        | O(N)           | 时间复杂度中的N表示删除的Key数量。从数据库删除中参数中指定的keys，如果指定键不存在，则直接忽略。还需要另行指出的是，如果指定的Key关联的数据类型不是String类型，而是List、Set、Hashes和Sorted Set等容器类型，该命令删除每个键的时间复杂度为O(M)，其中M表示容器中元素的数量。而对于String类型的Key，其时间复杂度为O(1)。 | 实际被删除的Key数量。                                        |
| **EXISTS** key                                               | O(1)           | 判断指定键是否存在。                                         | 1表示存在，0表示不存在。                                     |
| **MOVE** key db                                              | O(1)           | 将当前数据库中指定的键Key移动到参数中指定的数据库中。如果该Key在目标数据库中已经存在，或者在当前数据库中并不存在，该命令将不做任何操作并返回0。 | 移动成功返回1，否则0。                                       |
| **RENAME** key newkey                                        | O(1)           | 为指定指定的键重新命名，如果参数中的两个Keys的命令相同，或者是源Key不存在，该命令都会返回相关的错误信息。如果newKey已经存在，则直接覆盖。 |                                                              |
| **RENAMENX** key newkey                                      | O(1)           | 如果新值不存在，则将参数中的原值修改为新值。其它条件和RENAME一致。 | 1表示修改成功，否则0。                                       |
| **PERSIST** key                                              | O(1)           | 如果Key存在过期时间，该命令会将其过期时间消除，使该Key不再有超时，而是可以持久化存储。 | 1表示Key的过期时间被移出，0表示该Key不存在或没有过期时间。   |
| **EXPIRE** key seconds                                       | O(1)           | 该命令为参数中指定的Key设定超时的秒数，在超过该时间后，Key被自动的删除。如果该Key在超时之前被修改，与该键关联的超时将被移除。 | 1表示超时被设置，0则表示Key不存在，或不能被设置。            |
| **EXPIREAT** key timestamp                                   | O(1)           | 该命令的逻辑功能和EXPIRE完全相同，唯一的差别是该命令指定的超时时间是绝对时间，而不是相对时间。该时间参数是Unix timestamp格式的，即从1970年1月1日开始所流经的秒数。 | 1表示超时被设置，0则表示Key不存在，或不能被设置。            |
| **TTL** key                                                  | O(1)           | 获取该键所剩的超时描述。                                     | 返回所剩描述，如果该键不存在或没有超时设置，则返回-1。       |
| **RANDOMKEY**                                                | O(1)           | 从当前打开的数据库中随机的返回一个Key。                      | 返回的随机键，如果该数据库是空的则返回nil。                  |
| **TYPE** key                                                 | O(1)           | 获取与参数中指定键关联值的类型，该命令将以字符串的格式返回。 | 返回的字符串为string、list、set、hash和zset，如果key不存在返回none。 |
| **SORT** key [BY pattern] [LIMIT offset  count] [GET pattern [GET pattern ...]] [ASC\|DESC] [ALPHA] [STORE  destination] | O(N+M*log(M))  | 这个命令相对来说是比较复杂的，因此我们这里只是给出最基本的用法，有兴趣的网友可以去参考redis的官方文档。 | 返回排序后的原始列表。                                       |

 

  

### **服务器管理**

**1. 概述：**

Redis在设计之初就被定义为长时间不间断运行的服务进程，因此大多数系统配置参数都可以在不重新启动进程的情况下立即生效。即便是将当前的持久化模式从AOF切换到RDB也无需重启。
在Redis中，提供了一组和服务器管理相关的命令，其中就包含和参数设置有关的CONFIG SET/GET command。
 常用命令：`Info/flushall/save`

 **2. 相关命令列表：**

| **命令原型**                     | **时间复杂度** | **命令描述**                                                 | **返回值**                               |
| -------------------------------- | -------------- | ------------------------------------------------------------ | ---------------------------------------- |
| **CONFIGGET**parameter           |                | 主要用于读取服务器的运行时参数，但是并不是所有的配置参数都可以通过该命令进行读取。其中该命令的参数接受glob风格的模式匹配规则，因此如果参数中包含模式元字符，那么所有匹配的参数都将以key/value方式被列出。如果参数是*，那么该命令支持的所有参数都将被列出。最后需要指出的是，和redis.conf中不同的是，在命令中不能使用数量缩写格式，如GB、KB等，只能使用表示字节数量的整数值。 |                                          |
| **CONFIG SET**parameter value    |                | 该命令用于重新配置Redis服务器的运行时参数，在设置成功之后无需重启便可生效。然而并非所有的参数都可以通过该命令进行动态设置，如果需要获悉该命令支持哪些参数，可以查看CONFIG GET * 命令的执行结果。如果想在一个命令中设置多个同类型参数，如redis.conf配置文件中的save参数：*save 900 1/save 300 10*。在该命令中我们可以将多个key/value用双引号括起，并用空格符隔开，如：*config set save "900 1 300 10"*。 | OK表示设置成功，否则返回相关的错误信息。 |
| **CONFIG RESETSTAT**             | O(1)           | Reset INFO命令给出的统计数字。                               | 始终返回OK。                             |
| **DBSIZE**                       |                | 返回当前打开的数据库中Keys的数量。                           | Key的数量。                              |
| **FLUSHALL**                     |                | 清空当前服务器管理的数据库中的所有Keys，不仅限于当前打开的数据库。 |                                          |
| **FLUSHDB**                      |                | 清空当前数据库中的所有Keys。                                 |                                          |
| **INFO**                         |                | 获取和服务器运行状况相关的一些列统计数字。                   |                                          |
| **SAVE**                         |                | 设置RDB持久化模式的保存策略。                                |                                          |
| **SHUTDOWN**                     |                | 停止所有的客户端，同时以阻塞的方式执行内存数据持久化。如果AOF模式被启用，则将缓存中的数据flush到AOF文件。退出服务器。 |                                          |
| **SLAVEOF**host port             |                | 该命令用于修改SLAVE服务器的复制设置。如果一个Redis服务器已经处于SLAVE状态，*SLAVEOF NO ONE*命令将关闭当前服务器的被复制状态，与此同时将该服务器切换到MASTER状态。该命令的参数将指定MASTER服务器的监听IP和端口。还有一种情况是，当前服务器已经是另外一台MASTER的SLAVE了，在执行该命令后，当前服务器将终止和之前MASTER之间的复制关系，而将成为新MASTER的SLAVE，之前MASTER中的数据也将被清空，改为新MASTER中的数据。然而如果在当前SLAVE服务器上执行的是*SLAVEOF NO ONE*命令，那么该服务器只是中断与当前MASTER的复制关系，并升级为独立的MASTER，其中的数据也不会被清空。 |                                          |
| **SLOWLOG**subcommand [argument] |                | 该命令主要用于读取执行时间较长的命令。其中执行时间的评判标准仅为命令本身的执行时间，并不包括网络交互时间。和该命令相关的配置参数主要有两个，第一个就是执行之间的阈值(以微秒为单位)，即执行时间超过该值的命令都会被存入slowlog队列，以供该命令读取。第二个是slowlog队列的长度，如果当前命令在存入之前，该队列中的命令已经等于该参数，在命令进入之前，需要将队列中最老的命令移出队列。这样可以保证该队列所占用的内存总量保持在一个相对恒定的大小。由于slowlog队列不会被持久化到磁盘，因此Redis在收集命令时不会对性能产生很大的影响。通常我们可以将参数"*slowlog-log-slower-than*"设置为0，以便收集所有命令的执行时间。该命令还包含以下几个子命令：   1). *SLOWLOG GET N*: 从slowlog队列中读取命令信息，N表示最近N条命令的信息。   2). *SLOWLOG LEN*：获取slowlog队列的长度。   3). *SLOWLOG RESET*：清空slowlog中的内容。   最后给出SLOWLOG GET命令返回信息的解释。   redis 127.0.0.1:6379> slowlog get 10      1) 1) (integer)  5          *#**唯一表示符，在**Redis**重启之前，该值保证唯一。*        2) (integer) 1330369320 *#Unix Timestamp**格式表示的命令执行时间。*        3) (integer)  13        *#**命令执行所用的微秒数。*        4) 1)  "slowlog"        *#**以字符串数组的格式输出收集到的命令及其参数。*          2)  "reset" |                                          |

 

### **事务**

**1. 概述：**

和众多其它数据库一样，Redis作为NoSQL数据库也同样提供了事务机制。在Redis中，`MULTI/EXEC/DISCARD/WATCH`这四个命令是我们实现事务的基石。相信对有关系型数据库开发经验的开发者而言这一概念并不陌生，即便如此，我们还是会简要的列出Redis中事务的实现特征：
1) 在事务中的所有命令都将会被串行化的顺序执行，事务执行期间，Redis不会再为其它客户端的请求提供任何服务，从而保证了事物中的所有命令被原子的执行。
2) 和关系型数据库中的事务相比，在Redis事务中如果有某一条命令执行失败，其后的命令仍然会被继续执行。
3) 我们可以通过MULTI命令开启一个事务，有关系型数据库开发经验的人可以将其理解为"BEGIN TRANSACTION"语句。在该语句之后执行的命令都将被视为事务之内的操作，最后我们可以通过执行EXEC/DISCARD命令来提交/回滚该事务内的所有操作。这两个Redis命令可被视为等同于关系型数据库中的COMMIT/ROLLBACK语句。
4) 在事务开启之前，如果客户端与服务器之间出现通讯故障并导致网络断开，其后所有待执行的语句都将不会被服务器执行。然而如果网络中断事件是发生在客户端执行EXEC命令之后，那么该事务中的所有命令都会被服务器执行。
5) 当使用Append-Only模式时，Redis会通过调用系统函数write将该事务内的所有写操作在本次调用中全部写入磁盘。然而如果在写入的过程中出现系统崩溃，如电源故障导致的宕机，那么此时也许只有部分数据被写入到磁盘，而另外一部分数据却已经丢失。Redis服务器会在重新启动时执行一系列必要的一致性检测，一旦发现类似问题，就会立即退出并给出相应的错误提示。此时，我们就要充分利用Redis工具包中提供的redis-check-aof工具，该工具可以帮助我们定位到数据不一致的错误，并将已经写入的部分数据进行回滚。修复之后我们就可以再次重新启动Redis服务器了。



 **2. 相关命令列表：**

| **命令原型**           | **时间复杂度** | **命令描述**                                                 | **返回值**                                                   |
| ---------------------- | -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **MULTI**              |                | 用于标记事务的开始，其后执行的命令都将被存入命令队列，直到执行EXEC时，这些命令才会被原子的执行。 | 始终返回OK                                                   |
| **EXEC**               |                | 执行在一个事务内命令队列中的所有命令，同时将当前连接的状态恢复为正常状态，即非事务状态。如果在事务中执行了WATCH命令，那么只有当WATCH所监控的Keys没有被修改的前提下，EXEC命令才能执行事务队列中的所有命令，否则EXEC将放弃当前事务中的所有命令。 | 原子性的返回事务中各条命令的返回结果。如果在事务中使用了WATCH，一旦事务被放弃，EXEC将返回NULL-multi-bulk回复。 |
| **DISCARD**            |                | 回滚事务队列中的所有命令，同时再将当前连接的状态恢复为正常状态，即非事务状态。如果WATCH命令被使用，该命令将UNWATCH所有的Keys。 | 始终返回OK。                                                 |
| **WATCH**key [key ...] | O(1)           | 在MULTI命令执行之前，可以指定待监控的Keys，然而在执行EXEC之前，如果被监控的Keys发生修改，EXEC将放弃执行该事务队列中的所有命令。 | 始终返回OK。                                                 |
| **UNWATCH**            | O(1)           | 取消当前事务中指定监控的Keys，如果执行了EXEC或DISCARD命令，则无需再手工执行该命令了，因为在此之后，事务中所有被监控的Keys都将自动取消。 | 始终返回OK。                                                 |

 

 

 